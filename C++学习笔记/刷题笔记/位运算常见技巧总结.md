# 位运算常见技巧总结：

## 1、利用位运算实现乘法，除法：左移一位乘以2；右移一位除以2

```c
1010 << 1 -- 左移一位，即10100，十进制表示为20
1010 >> 1 -- 右移一位，即101，十进制表示为5（无符号数处理）
```

## 2、利用位运算判断奇偶数：最后一位为0.则是偶数；最后一位为1，则是奇数

``` c
最后一位为0，则为偶数；最后一位为1，则为奇数
n = 1011 -- 十进制表示为11，奇数 
n = 1010 -- 十进制表示为10，偶数
```

## 3、交换两个数：a^ b^b=a (a异或b再异或b，等于a)

```c
a = 1011
b = 0101
a^b = 1110
a^b^b = 1110 ^ 0101 = 1011
```

## 4、异或运算的三大性质

a^0=a
a^a=0
异或运算满足交换律和结合律：a ^ b ^ a=b ^ a ^ a =b ^ (a ^ a)=b ^0 = b

**leetcode**
136.只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
    int ans=0;
    for(auto i:nums){
        ans^=i;
    }
    return ans;
    }
};
```



## 5、n&(n-1):相当于把n最右边的1变成0，其余不变

```c
      5  = 0000 0101
     -5  = 1111 1011 (5补数表示-5)
5 & (-5) = 0000 0001 -- 获取了5的二进制最右边的1

       10  = 0000 1010
      -10  = 1111 0110 (10补数表示-10)
10 & (-10) = 0000 0010 -- 获取了10的二进制最右边的1
```

## 6、获取二进制中最右边的1：x&(-x)

```c
      5  = 0000 0101
     -5  = 1111 1011 (5补数表示-5)
5 & (-5) = 0000 0001 -- 获取了5的二进制最右边的1

       10  = 0000 1010
      -10  = 1111 0110 (10补数表示-10)
10 & (-10) = 0000 0010 -- 获取了10的二进制最右边的1
```

## 7、实现加法(int a, int b)

```C++
while (b !=0) {
    int c = unsigned int (a&b) <<1;
    a^=b;
    b =c;
}
```

## 8.位运算解排列问题，将所有可能的排列在2n中的1来解集

剑指2 079 所有子集

给定一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集。解集不能包含重复的子集。你可以按任意顺序返回解集。

实例：

**输入：**nums = [1,2,3]
**输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> t;
        vector<vector<int>> ans;
        int n = nums.size();
        for(int mask = 0; mask < (1 << n); mask++) {
            t.clear();
            for(int i = 0 ; i < n ;i++) {
                if (mask & (1 << i)) {
                    t.push_back(nums[i]);
                }
            }
            ans.push_back(t);
        }
        return ans;
    }
};
```

