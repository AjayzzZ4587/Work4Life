# 面试必背

## C++基础

### 1、面向对象的三大特性

封装、继承、多态

**封装和继承目的都是为了代码重用，多态目的是为了接口重用**

封装将客观实物抽象成类，并且把自己的属性和方法让可信的类或对象操作，对不行的类进行隐藏

继承是对现有类的扩展

C++多态性主要通过虚函数实现的，虚函数运行子类重写override（与隐藏有区别）。

多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。

运行时才确定绑定地址，就属于晚绑定。

目的：接口重用。

### 2、类的访问权限

private、protected、public

在公共权限内的成员类内可以访问，类外也可以访问。public

可以由类的函数、子类的函数、友元函数进行访问，也可以由类对象来访问，也可以用成员运算符来访问。

在保护权限内的成员类内可以访问，类外不可以访问。protected

可以被类的成员函数访问，但不能被类对象所访问，也就是不能通过类对象的成员运算符来访问。子类也可以访问

在私有权限内的成员类内可以访问，类外不可以访问。private

只能被该类的方法和友元函数访问，子类函数无法访问。这个权限的封装程度最高。

struct默认成员是public属性，class成员默认是private属性，在继承与上以保持这点，class可以使用模板，struct不行

### 3、类的构造函数、析构函数、赋值函数、拷贝函数

构造函数和普通函数一样具有重载特性，所以编写程序的人可以给一个类添加任意多个构造函数，来使用不同的参数来进行初始化对象。

#### 构造函数的初始化表

构造函数初始化表的使用规则：

<1> 如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数。

```C++
class A

{   …

    A(int x); // A 的构造函数

};

class B : public A

{   …

    B(int x, int y);// B 的构造函数

};

B::B(int x, int y): A(x) // 在初始化表里调用A 的构造函数

{   …

}
```

<2> 类的const常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化。

<3> 类的数据成员的初始化可以采用初始化表或函数体内赋值两种方式，这两种方式的效率不完全相同。

```C++
B::B(const A &a) : m_a(a)
{  
    …
}

B::B(const A &a)
{   
    // 这里会暗地里创建m_a对象，再调用A的赋值函数，将参数a赋给m_a
    m_a = a;
    … 
}
```

当然内部成员数据类型上区别不大

#### 拷贝构造函数和赋值函数的区别

拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用。

```C++
String a(“hello”);
String b(“world”);
String c = a; // 调用了拷贝构造函数，最好写成c(a);
c = b; // 调用了赋值函数
```

#### 析构函数

析构函数为什么是虚函数？

想要析构父类对象指针的子类，就必须要有

![image-20220428103529791](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220428103529791.png)

### 4、移动构造函数与拷贝构造函数对比

https://www.cnblogs.com/hosseini/p/15089358.html

### 5、深拷贝与浅拷贝的区别

https://blog.csdn.net/caoshangpa/article/details/79226270

### 6、空类有哪些函数？空类的大小？

空类大小为1，

1> 缺省构造函数

2>缺省拷贝构造函数

3>缺省析构函数

4>缺省赋值运算符

5>缺省取址运算符

6>缺省取址运算符const

7、内存分区：全局区、堆区、栈区、常量区、代码区

### 8、C++与C的区别

C语言是面向过程语言，而C++是面向对象语言。

### 9、struct与class的区别

struct中只能定义数据成员(不能定义成员函数，不过可以用函数指针调用函数)

1) 默认的继承访问权限。struct是public的，class是private的;

2) struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的;

3) “class"这个关键字还用于定义模板参数，就像“typename"。但关键字“struct"不用于定义模板参

### 10、struct内存对齐

内存对齐主要遵循以下原则:

1. 对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍

   ```c++
   #include <stdio.h>
   using namespace std;
   struct test1{
      char ch;	
      int in;
   };
   struct test2{
      char ch;	
      double db;
   };
   int main(){
      test1 tmp1;
      test2 tmp2;
      printf("%d\n", sizeof(tmp1));
      printf("%d\n", sizeof(tmp2));
   } 
   
   ```

   输出结果是8， 16

2. **结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍。**

   ```c++
   #include <stdio.h>
   using namespace std;
   struct test1{
   	int in;
   	char ch;	//为使结构体size能整除int的大小，即整除4，需在ch后补3个字节，即[ch][ ][ ][ ]
   };
   struct test2{
   	double db;
   	char ch;	//为使结构体size能整除double的大小，即整除8，需在ch后补7个字节，即[ch][ ] * 7		
   };
   struct test3{
   	int in;
   	double db;
   	char ch;	//同test2	
   };
   int main(){
   	test1 tmp1;
   	test2 tmp2;
   	test3 tmp3;
   	printf("%d\n", sizeof(tmp1));
   	printf("%d\n", sizeof(tmp2));
   	printf("%d\n", sizeof(tmp3));
   } 
   ```

   

3. 如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。

4. 对于结构体嵌套，按照结构体展开后的内存对齐来处理

   ```c++
   #include <stdio.h>
   using namespace std;
   struct A{
   	char c1, c2, c3;		
   };
   struct B{
   	char c4;
   	A a;	
   };
   
   int main(){
   	A a;
   	B b;
   	printf("%d\n", sizeof(A));
   	printf("%d\n", sizeof(B));
   }
   ```

   

为什么需要内存对齐？

结构体的对齐明明浪费了更多的空间，但是却提高了内存系统性能！最重要的考虑是提高内存系统性能。为了简化电路设计，实际上计算机会将字节组成一个大点的格子，32 位机器，就以 4 个字节作为一个格子。64 位机器，就以 8 字节作为一个格子。在 64 位机上，就算读取 1 字节的数值，也需要读取整个 8 字节的格子。例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至瘫痪。

在网络应用中，为了节省带宽，数据包不作任何对齐的通信协议。

### 11、new/delete与malloc/free的区别

![image-20220428110155519](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220428110155519.png)





### 12、内存泄露的情况

1、在类的构造函数和析构函数中没有匹配的调用new和delete函数

一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存

2、没有正确地清除嵌套的对象指针

3、在释放对象数组时在delete中没有使用方括号

方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。

释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数

**4、指向对象的指针数组不等同于对象数组**

**对象数组**是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间

指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。

5、缺少拷贝构造函数

两次释放相同的内存口是一种错误的做法，同时可能会造成堆的奔溃。
按值传递会调用(拷贝)构造函数，引用传递不会调用。
在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。

6、缺少重载赋值运算符

这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图:

![image-20220423153346044](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220423153346044.png)

7、关于nonmodifying运算符重载的常见意思

a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针

b. 返回内部静态对象的引用。

c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收

解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&而是int

8、没有将基类的析构函数定义为虚函数

当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

13、sizeof与strlen对比

### 14、指针与引用的区别

1、指针是一个变量，存储的是变量(对象)的地址，引用是变量的别名
2、指针可以为空，引用定义时必须初始化
3、指针在初始化之后可以改变指向，引用在初始化之后不可在改变
4、指针可以有多级，引用只有—级
5、sizeof指针得到的是本指针的大小,sizeof引|用得到的是引用所指向变量的大小
6、当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以
7、引用本质是一个指针，同样会占4字节内存;指针是具体变量，需要占用存储空间
8、不存在指向空值的引用，必须有具体实体;但是存在指向空值的指针

### 15、野指针产生与避免

**指向被释放的或者访问受限内存的指针**

野指针：随机指向一块内存的指针（容易造成内存泄露）

​				不一定每次都产生段错误，也许有一次刚好分配到一个已经分配好的空间。

​				非法访问：不经过操作系统的允许，来访问内存空间。

 养成良好的编码习惯：

                （1）当没有指针指向时，要置为NULL
    
                （2）给指针指向的空间赋值时，一定要给指针分配空间
    
                （3）检查是否分配成功
    
                （4）分配成功之后，初始化
    
                （5）使用时，注意不要越界
    
                （6）使用完之后，free
    
                （7）free之后再次置NULL
当看到指针指向NULL时：

​         ①注意不能对指针指向的空间做操作

​         ②提醒这是一个野指针

危害：

野指针的问题在于，指针指向的内存已经无效了，而指针没有被置空，解引用一个非空的无效指针是一个未被定义的行为，也就是说不一定导致段错误，野指针很难定位到是哪里出现的问题，在哪里这个指针就失效了，不好查找出错的原因。所以调试起来会很麻烦，有时候会需要很长的时间。

一种情况：

指针操作超越变量作用域:不要返回指向栈内存的指针或引用，因为栈内存在函数结束的时候会被释放．示例

```C++
class A(
public:
void Func(void)(
cout << "Func of class A" << endl;
};
    
class B
public:
    A *p;
void Test(void){
A a;
p = &a; //注意a的生命期，只在这个函数Test中,而不是整个class B
}
void Test1 (){
p->Func(); // p是“"野指针”
}
};

```

16、多态：动态多态、静态多态
17、虚函数实现动态多态的原理、虚函数与纯虚函数的区别
18、继承时，父类的析构函数是否为虚函数？构造函数能不能为虚函数？为什么？
19、静态多态：重写、重载、模板
20、static关键字：修饰局部变量、全局变量、类中成员变量、类中成员函数
21、const关键字：修饰变量、指针、类对象、类中成员函数
22、extern关键字：修饰全局变量

### 23、volatile关键字：避免编译器指令优化

https://blog.csdn.net/p1279030826/article/details/106383316

24、四种类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast

### 25、右值引用

https://www.bilibili.com/video/BV1Df4y1C7xs?p=1

![image-20220404105746202](C:\Users\45130\OneDrive\C++学习笔记\面经积累\面试必背.assets\image-20220404105746202.png)

### 26、std::move函数

std::move只是进行了左右值的转换，也就是类型的转换，并没有改变对象本身。

**实际上这里的避免内存拷贝依赖于被std::move转换的对象的具体实现**，std::move只是将对象以右值的形式告诉接受者，这个对象的赋值操作可以**直接使用其内存地址，**而不是创建新内存拷贝数据。

```c++
class String
{
public:
    String(const char* buf)
    {
    	_buf = new char[strlen(buf) + 1];
        strcpy(_buf, buf);	// 内存拷贝
    }
    
	String(const String& str)
    {
     	_buf = new char[strlen(str._buf) + 1];
        strcpy(_buf, str._buf);	// 内存拷贝
    }
    
    String(String&& str)
    {
        _buf = str._buf;		// 直接使用内存地址
        str._buf = nullptr;
    }
    
private:
	char* _buf;	
}

void main()
{
    String str("hello world!");
    String str1(str);
    String str2(std::move(str));
}
```

实际在使用的过程中，如果我们认为一个对象不再需要了，想要直接把内部资源转移到另外一个对象的时候，而且这个类型有右值引用的版本，就可以通过std::move将对象转换成右值引用。

还是上面那个String举个例子来看看他的使用场景：

```c++
String getString()
{
	String str("hello world!");
    return std::move(str);
}
```

在`getString`这个函数中，我们构造了一个str对象。这个对象要返回给调用者。假如不对str进行std::move转换，那么会有1次拷贝构造发生。而通过std::move转换之后就会调用右值引用参数的构造函数，这样就避免了内存拷贝。

### 27、四种智能指针及底层实现：auto_ptr、unique_ptr、shared_ptr、weak_ptr

**std:weak_ptr Temp/No Ownership**
Must be converted to a std: : shared_ptr before accessing

Models a temporary ownership
	Access if the object still exist  检测是否还存在，利用它的特性
	OK if the object was already destroyed 

```c++
auto e1 = std : :make_shared<Entity>( );
std: :weak_ptr<Entity> ew = e1; // construct from a shared_ptr
if (std:: shared_ptr<Entity> e2 = ew.lock())  // convert to a shared_ptr
e2->DoSomething();
```



### 28、shared_ptr中的循环引用怎么解决？（weak_ptr）

https://blog.csdn.net/weixin_45880571/article/details/119345415

29、vector与list比较
30、vector迭代器失效的情况
31、map与unordered_map对比
32、set与unordered_set对比
33、STL容器空间配置器



![image-20220404125751666](C:\Users\45130\OneDrive\C++学习笔记\面经积累\面试必背.assets\image-20220404125751666.png)

### 34、const

https://www.bilibili.com/video/BV1Fx411W7VS?spm_id_from=333.337.search-card.all.click

## 计算机网络

1、OSI7层网络模型：应用层、表示层、会话层、运输层、网络层、链路层、物理层
 2、TCP/IP四层网络模型：应用层、运输层、网际层、接口层
 综合OSI与TCP/IP模型，学习五层网络模型：
 从上向下架构：应用层、运输层、网络层、链路层、物理层
 链路层：
 3、MTU
 4、MAC地址
 网络层：
 5、地址解析协议
 6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？
 7、网络层转发数据报的流程
 8、子网划分、子网掩码
 9、网络控制报文协议ICMP
 10、ICMP应用举例：PING、traceroute
 运输层：
 11、TCP与UDP的区别及应用场景
 12、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）
 13、TCP滑动窗口原理

####  14、TCP超时重传时间选择

![image-20220321152200012](C:\Users\45130\OneDrive\C++学习笔记\面经积累\面试必背.assets\image-20220321152200012.png)

 15、TCP流程控制
 16、TCP拥塞控制（一定要弄清楚与流量控制的区别）
 17、TCP三次握手及状态变化。为啥不是两次握手？
 18、TCP四次挥手及状态变化。为啥不是三次挥手？
 19、TCP连接释放中TIME_WAIT状态的作用
 20、SYN泛洪攻击。如何解决？
 21、TCP粘包
 22、TCP心跳包
 23、路由器与交换机的区别
 24、UDP如何实现可靠传输

应用层：
 25、DNS域名系统。采用TCP还是UDP协议？为什么？
 26、FTP协议（了解）
 27、HTTP请求报文与响应报文首部结构
 28、HTTP1.0、HTTP1.1、HTTP2.0对比
 29、HTTP与HTTPS对比
 30、HTTPS加密流程
 31、方法：GET、HEAD、POST、PUT、DELETE
 32、状态码：1**、2**、3**、4**、5**
 33、cookie与session区别
 34、输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）

## 操作系统

### 1、进程与线程区别

区别一：线程是比进程小的单位。

区别二：进程拥有相互独立的内存单元，多个线程可以共享内存，可以提高运行效率。

区别三：线程不同单独存在，进而让一个进程可以在多个线程的情况下，完成工作。

### 2、线程同步的方式：互斥锁、自旋锁、读写锁、条件变量

#### 互斥锁

互斥锁：有已锁定和未锁定两种状态。只能同时被一个线程锁定，锁的线程拥有所有权，也可以解锁。当线程尝试对正在使用的互斥锁加锁时，线程将阻塞休眠或接口返回错误，具体行为与使用的lock接口相关。

锁的争用：当处于使用状态，多个线程都等待获取该锁，高度争用状态将带来系统性能下降，高度争用状态下，如果锁被长时间持有或频繁获取，将导致严重的性能瓶颈。

#### 自旋锁

自旋锁和互斥量类似，但当线程尝试获取已被加锁的自旋锁时，线程不会进入休眠，**将一直处于忙循环-自旋**，等待自旋锁被释放。自旋锁可用于如下情况：锁被持有的时间很短（也就是临界区执行时间很短），比一个线程重新调度切换来得快，以减少线程调度带来的成本。

自旋锁相比互斥锁的底层实现，更简单，往往采用汇编实现，加锁和解锁更省时。自旋锁一般用于内核同步中使用，应用编程中一般较少使用。

#### 读写锁

读写锁：为啥会诞生读写锁？因为多线程并发读共享数据是安全的，如果还使用互斥锁，线程只能串行的读取数据，影响系统并发性能。读写锁有三种状态：读加锁状态、写加锁状态、解锁状态。读写锁只保证了同时只有一个线程对共享资源的修改操作，可以允许多个线程并发读，提高了并发读的系统性能。使用场景：读写锁比较适合于对数据结构读的次数远大于写的次数。

通过划分多个状态，让高并发环境下能够更好的处理线程同步问题。

#### 条件变量

条件变量：考虑这样一种场景：生产者和消费者线程访问共享数据，采用互斥锁保护访问；基本的代码模型如下：不难看到一种缺陷，当生产者线程avail变量还未满足消费条件时，消费者线程也将循环的加锁、解锁对条件进行检查，这消耗了CPU资源；如果生产者满足消费条件时，在发出信号通知消费者；消费者线程在收到信号之前一直处于休眠状态，便会减少不必要的线程反复切换。

```C
/* 生产者线程 */
{
	pthread_mutex_lock(&mtx);
    avail++;
    pthread_mutex_unlock(&mtx);
}

/* 消费者线程 */
{
	pthread_mutex_lock(&mtx);
    if (avail >= 1000) {
        /* Do something with produced unit */
    }
    pthread_mutex_unlock(&mtx);
}
```

条件变量必须与互斥锁配对使用，因为条件变量的等待接口在让线程进入休眠前，会先对保护其共享变量的互斥锁进行解锁，以便其他线程可以操作共享变量；收到条件变量的信号通知时，线程被唤醒后必须对互斥量再次加锁，因为接下来线程将会处理共享变量。

条件变量的主要操作是发出和等待信号；条件变量并不保存具体状态值，一旦发出信号，就代表条件可能满足了，等待条件变量的线程将被唤醒。

```c
#include <pthread.h>

int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, \
							const struct timepsec *abstime);
```

函数 pthread_cond_signal 和 pthread_cond_broadcast 均可针对由参数 cond 所指定的条件变量发送信号。pthread_cond_wait 函数将阻塞线程，直至收到条件变量 cond的通知。

函数 pthread_cond_signal 和 pthread_cond_broadcast 之间的差别在于，二者对阻塞于 pthread_cond_wait 的多个线程处理方式不同。pthread_cond_signal 只能保证至少唤醒一条线程，而 pthread_cond_broadcast 会唤醒所有被阻塞线程。

使用 pthread_cond_broadcast 总能产生正确的结果，被多余唤醒的线程发现不满足条件再休眠便可，但浪费了CPU的占用。

有些情况更适合使用 pthread_cond_signal 来得更高效 ，当所有等待线程都在执行相同的任务（各线程关联于条件变量的判定条件相同），使用 pthread_cond_signal 更具效率，因为无论把谁唤醒都一样，都将完成任务，其他线程再醒来也无事可做。

相比之下，函数 pthread_cond_broadcast 所处理的情况是：处于等待状态的所有线程执行的任务不同（各线程关联于条件变量的判定条件不同）。

```c
static uint32 avail = 0;
/* 生产者线程 */
{
    bool condition = false;
	pthread_mutex_lock(&mtx);
    avail++;
    if (avail >= 1000) {
        condition = true;
    }
    pthread_mutex_unlock(&mtx);
    pthread_cond_signal(&cond);
}

/* 消费者线程 */
{
	pthread_mutex_lock(&mtx);
    
    while (avail < 1000)
    	pthread_cond_wait(&cond, &mtx);
    
    if (avail >= 1000) {
        /* Do something with produced unit */
    }
    pthread_mutex_unlock(&mtx);
}
```

生产者线程中先调用了pthread_mutex_unlock，接着调用了pthread_cond_signal；先解锁与共享变量相关的互斥量，再就对应的条件变量发出信号。这两步顺序如果颠倒调用呢？在某些实现中，先解锁互斥量再通知条件变量，可能比反序执行效率更高；如果仅在通知条件变量后才解锁互斥量，执行条件变量等待的线程可能会在互斥量仍处于加锁状态醒来，将再次进入休眠，会导致两个多余的上下文切换。

消费者线程中为何要用while循环调用pthread_cond_wait等待条件变量通知呢？这是因为线程收到条件变量的通知后（也就是pthread_cond_wait接口返回），未必就一定满足条件，也许可能是虚假通知（线程得到执行前，有其他线程已经再次修改了共享变量）。

####  3、互斥锁与自旋锁的底层区别

实现方式的区别：互斥锁是基于自旋锁而实现的，所以自旋锁相较于互斥锁更加底层。
开销上的区别：获取不到互斥锁会陷入阻塞状态（休眠），直到获取到锁时被唤醒；而获取不到自旋锁会在原地“自旋”，直到获取到锁；**休眠和唤醒的开销是很大的，所以互斥锁的开销远高于自旋锁、自旋锁的效率远高于互斥锁**；但如果长时间“自旋”等待，会使得CPU使用效率降低，故自旋锁不用于等待时间比较长的情况。

使用场景的区别：**自旋锁在用户态应用程序中使用的比较少，通常在内核代码中使用的比较多**；因为自旋锁可以**在中断服务程序中使用**，而互斥锁则不行，在执行中断服务程序时要求不能休眠、不能被抢占（**内核使用自旋锁会自动禁止抢占**），一旦休眠意味着执行中断服务函数时主动交出了CPU使用权，休眠结束时无法返回到中断服务函数中，这样就会导致死锁。

####  4、孤儿进程与僵尸进程

在Unix/Linux系统中，正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束。当一个进程调用exit命令结束自己的生命时，其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等，但是留下一个称为僵尸进程的数据结构，这个结构保留了一定的信息（包括进程号the process ID，退出状态，运行时间)，这些信息直到父进程通过wait()/waitpid()来取时才释放。这样设计的目的主要是保证只要父进程想知道子进程结束时的状态信息，就可以得到

**僵尸进程:**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。

**孤儿进程:**一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

##### 僵尸进程与孤儿进程带来的问题

僵尸进程虽然不占有任何内存空间，但如果父进程不调用wait()/ waitpid()的话，那么保留的信息就不会释放，其进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而 init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。

##### 解决方案

方案一︰父进程通过wait和waitpid 等函数等待子进程结束，但这会导致父进程挂起，所以这并不是一个好办法，父进程如果不能和子进程并发执行的话，那我们创建子进程的意义就没有。同时—个wait只能解决一个子进程，如果有多个子进程就要用到多个wait

方案二:通过信号机制：
子进程退出时，向父进程发送SIGCHILD信号，父进程处理SIGCHILD 信号，在信号处理函数中调用wait进行处理僵尸进程。子进程退出时，向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号，在信号处理函数中调用WAIT进行处理僵尸进程。

(3）方案三: fork两次:
原理是将进程成为孤儿进程，从而其的父进程变为init进程，通过init进程处理僵尸进程。具体操作为:父进程一次 fork()后产生一个子进程随后立即执行wait(NULL)来等待子进程结束，然后子进程fork()后产生孙子进程随后立即exit(O)。这样子进程顺利终止(父进程仅仅给子进程收尸，并不需要子进程的返回值)，然后父进程继续执行。这时的孙子进程由于失去了它的父进程(即是父进程的子进程)，将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init,Init进程在其子进程结束时会自动收尸，这样也就不会产生僵死进程了。

(4)方案四:kill父进程:
严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大星的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉(也就是通过kill发送 SIGTERM或者SIGKILL.信号啦)。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。

####  5、死锁及避免

场景：互不相让的独木桥

系统中只有一台CD-ROM驱动器和一台打印机，某一个进程占有了CD-ROM驱动器，又申请打印机；另一进程占有了打印机，还申请CD-ROM。结果，两个进程都被阻塞，永远也不能自行解除。

**死锁的必要条件：**

互斥条件、不可抢占条件、占有且申请条件、循环等待

上述四个条件的避免都会存在问题。

避免死锁的算法，**银行家算法**

在实际操作系统中还能够采用死锁检测与恢复方法来排除死锁。

死锁的恢复：

一、直接重启

二、撤销进程，剥夺资源。

三、回退策略。

#####  6、多线程与多进程比较

1.线程是进程的子集,一个进程可能由多个线程组成;

2.多进程的数据是分开的,共享复杂,需要用IPC,但同步简单;

3.多线程共享进程数据,共享简单,但同步复杂。

####  7、进程间通信：PIPE、FIFO、消息队列、信号量、共享内存、socket

##### 1.管道pipe:

管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

在Linux中，[|]

```c
ps auxf | grep mysql
```

上面命令行里的[|]竖线就是一个管道，它的功能就是将前一个命令(ps auxf)的输出，作为后一个命令(grep mysql)的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。因为没有名字，也叫做匿名管道，用完就销毁了。

##### 2命名管道FIFO:

有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

在使用前，需要先通过mkfifo命令来创建，并且指定管道名字：

```C
mkfifo myPipe
```

myPipe就是这个管道的名称，基于Linux一切皆文件的理念，所以管道也是以文件的方式存在。

往管道中写入数据：

```c
echo "hello" > myPipe     //将数据写进管道
    					 // 停住了，由于管道里还有数据，需要等到没有数据了才会退出
```

```c
cat < myPipe  //读取管道里的数据
hello
```

管道这种通信方式效率低，不适合进程间频繁地交换数据。好处是比较简单。

##### 3.消息队列MessageQueue:

消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

具体操作逻辑是：A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。同理，B进程要给A进程发送消息也是如此。

消息队列是保存在内核中的消息链表。生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，会一直存在。

不足是通信不及时，二是附近大小有限制。

**不适合较大数据的传输。**

**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。有穿插用户态和内核态的这一层开销。

##### 4.共享存储SharedMemory:

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和进程B的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。
**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。**这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。

![image-20220420154256485](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220420154256485.png)

##### 5.信号量Semaphore:

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。**

与共享内存通信方式搭配使用，防止多个进程竞争共享资源，造成数据错乱。

##### 6.套接字Socket:

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了**

##### 7.信号( sinal ):

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号：

```c
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；

如果进程在后台运行，可以通过 `kill` 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：

- kill -9 1050 ，表示给 PID 为 1050 的进程发送 `SIGKILL` 信号，用来立即结束该进程；

所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。

信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

**1.执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。

**2.捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。

**3.忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。

https://blog.csdn.net/modi000/article/details/122084165

####  8、管道与消息队列对比

消息通信方式以消息缓冲区为中间介质，通信双方的发送和接收操作均以消息为单位。在存储器中，消息缓冲区被组织成队列，通常称之为消息队列。

消息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大

####  9、fork进程的底层：读时共享，写时复制

linux给应用程序首先分配的是虚拟内存Q，然后再通过mmu(Memory Management Unit)将虚拟内存映射到物理内存。这样的好处是每一个进程都可以使用4G内存空间(0-3用户态，3-4内核态)。

使用fork产生的父子进程读时共享，写时复制。比如在父进程内原来有一个全局变量Q，如果fork之后**父子进程都没有去改变这个变量的值，那么内存中全局区这个变量只会存在一份，**所谓读时共享;但是如果fork后**父进程或者子进程改变了这个变量的值**，那么这个变量将会在内存全局区存在两份，**父子进程各自拥有各自的副本，这就是写时复制**（不仅是全局变量，堆，栈等等也是)。

####  10、线程上下文切换的流程

当一个线程的时间片用完，或者因自身原因被迫暂停运行，此时另一个线程会被操作系统选中来占用处理器上下文切换(Context Switch):一个线程被暂停剥夺使用权，另一个线程被选中开始或者继续运行的过程
切出:一个线程被剥夺处理器的使用权而被暂停运行
切入:一个线程被选中占用处理器开始运行或者继续运行
切出切入的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是上下文

####  11、进程上下文切换的流程

进程上下文切换的步骤如下:
1.由中断、异常、系统调用等触发中断，将cpu切换为内核模式，将eip，esp，eflages压入内核堆栈。
2.保存硬件未来得及保存的现场信息。
3.调用中断服务程序。
4.检查PCB中的need_resched标志位，若有效则调用schedule()函数完成进程调度，schedule ()会执行以下步骤;
	1.调用pick_next_task ()根据相关调度算法得到下一个待运行的进程。
	2.调用context_switch()执行以下步骤:
				1.调用switch_mm()将虚拟内存地址映射到待运行进程，恢复内存管理相关信息。
         	   2.调用switch_to()保存原来进程的cpu现场信息，恢复待运行进程的cpu现场信息。
5.中断返回，弹出eip, esp,eflages，将cpu切换为用户工作模式。

####  12、进程的调度算法

周转时间=进程结束的时间 - 进程到达的时间；
带权周转时间=周转时间 / 执行时间；

平均周转时间计算：

ATT:

由等待时间+运行时间/总的进程

以FCFS算法为例：

![image-20220420212624930](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220420212624930.png)

常见的进程调度算法有：

##### 一、先来先服务

算法：把处理器分配给最先进入就绪队列的进程。

优点：易于实现

缺点：表面上公平，服务质量不佳，对短进程不利，通常让平均周转时间变长。

##### 二、短作业优先调度算法

算法：从就绪队列中选出“下一个CPU执行期”最短的进程，来执行。

优点：可获得较好的调度性能

缺点：进程的CPU执行期难以确定，对长进程不利。

##### 三、最高响应比优先调度算法

算法：响应比 = （等待时间 + 要求的服务时间）/要求的服务时间，每次选取响应比最高的进程调度。

优点：照顾了短进程，也考虑了等待时间。

缺点：计算响应比有一定的系统开销。

##### 四、优先级调度算法

算法：将CPU分配给就绪队列中优先级最高的进程。

静态优先级：在进程创建时确定，确定后运行期保持不变。

确立依据有：进程的类型、进程对资源的需求、用户申请的优先级

优点：简单。

缺点：不能动态反映进程特点，系统调度性能差。

**动态优先级:**进程在开始创建时，根据某种原则确定一个优先级后，随着进程执行时间的变化，其优先级不断地进行动态调整。(个人理解:这种机制有点像高中生物里的负反馈调节，运行产生的结果反过来抑制这种运行，维持了一种动态的平衡;譬如:抗利尿激素的作用机制。)

- 确定依据：根据进程占有的CPU时间的长短来决定，占有时间越长优先级越低；根据进程等待CPU的时间来决定，时间越长优先级越高。
- 优点：克服了静态优先级的缺点。
- 缺点：需付出一定系统开销。

##### 五、时间片轮转调度算法

**算法：**通常用在分时系统，它轮流地调度系统中所有就绪进程，使就绪进程依次获得一个时间片的运行时间(记为q)。系统为就绪队列中的每一个进程分配一个时间片，在使用完一个时间片后即使进程还没有运行完毕，也要强迫其释放处理机，让给另一个进程使用。它自己则返回到就绪队列末尾，排队等待下一次调度的到来。q的大小不仅影响CPU的利用率，也影响平均周转时间。**时间片长短确定遵循原则**——既要保证系统各个用户进程及时地得到响应，又不要由于时间片太 短而增加调度的开销，降低系统的效率。

- 太大：无异于先来先服务。
- 太小：调度程序频率上升，系统耗费在调度上的时间增加，真正运行用户程序的时间减少。

**进程执行时可能发生的三种情况：**

- 进程未用完一个时间片便结束，这时系统应提前进行调度。
- 进程在执行过程中提出I/O请求而阻塞，系统应将它放入相应的阻塞队列并重新调度。
- 进程用完一个时间片后尚未完成。系统应将它重新放到就绪队列的末尾，等待下次执行。

##### 六、前后台调度算法

**算法：**该方法用在批处理和分时相结合的系统中。将分时用户作业放在前台，把批处理作业放在后台。系统对前台作业按照时间片轮转法进行调度，仅当前台无作业时，才把处理机分配给后台作业的进程。后台进程通常按先来先服务方式运行。

**优点：**使分时用户进程得到及时响应，又提高了系统资源的利用率。

##### 七、多级反馈队列轮转算法： 

系统设置多个不同优先级的就绪队列，每次调度总是先调度优先级高的队列，仅当该队列空时，才调度次高优先级队列。它是时间片调度算法与先来先服务调度算法的结合。实行这种调度算法时，系统维持多个就绪队列。每个就绪队列具有不同的调度级别可以获得不同长度 的时间片。
通常进程刚被创建时和因请求I/O未用完时间片的进程由阻塞状态再次转换为就绪状态时，排在最高优先级队列。
在这个队列中运行2-3个时间片未完成的进程排列下一个较低优先级队列。
不论什么时候，只要较高优先级队列有进程进入，立即转进程调度，及时调度较高优先级队列进程。  
优点：能较好地满足各类作业的用户要求，既能使分时用户作业得到满意的响应，又能使批处理用户的作业获得较合理的周转时间。

![image-20220420214952043](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220420214952043.png)

####  13、阻塞IO与非阻塞IO

阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞是指用户空间的执行状态。
非阻塞IO，指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户操作，即处于非阻塞IO状态，内核空间会立即返回给用户一个状态值。

阻塞IO：调用线程一直在等待，不能干别的事情。
非阻塞IO：调用线程拿到内核返回的状态值后，IO操作能干就干2，不能就干别的事情。

####  14、同步与异步的概念

**同步：**是指一个进程在执行某个请求的时候，若这个请求没有执行完成，
那么这个进程将会一直等待下去，直到这个请求执行完毕，才会继
续执行下面的请求。

**异步：**是指一个进程在执行某个请求的时候，如果这个请求没有执行完毕，进程不会等待，而是继续执行下面的请求。

####  15、静态链接与动态链接的过程

![image-20220421151429867](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220421151429867.png)

win上市dll，linux是.so

链接的三种方式:
1.静态链接:在程序运行之前,
先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
2.装入时动态链接:将各目标
模块装入内存时，边装入边链接的链接方式。
3.运行时动态链接:在程序执
行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

首先大概介绍一下，编译分为3步，首先对源文件进行预处理，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成*.i文件；然后进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成*.s的汇编文件；最后进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件。以上就是编译的过程，下面主要介绍两种链接方式--静态链接和动态链接。

##### 1.为什么要进行静态链接

​        在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个*.c文件会形成一个*.o文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接

##### 2.静态链接的原理

​     由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件

##### 3.静态链接的优缺点

        静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
##### 1.为什么会出现动态链接

​        动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。

##### 2.动态链接的原理

​        动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：

```tex
    假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。
```

##### 3.动态链接的优缺点

​        动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

        据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。

##### 4.动态链接地址是如何重定位的呢？

​        前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。

####  16、虚拟内存概念（非常重要）

##### 虚拟内存的作用

- 虚拟内存将主存看成是一个存储在**磁盘上的地址空间的高速缓存**，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，可以**高效地使用主存**。
- 虚拟内存为**每个进程提供了一致的地址空间**，简化了内存管理。
- 虚拟内存保护了每个进程的地址空间不被其他进程破坏。

分页算法：

页号=逻辑地址/页面长度(取除法的整数部分)
页内偏移量=逻辑地址%页面长度（取除法的余数部分)

![image-20220422095249547](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422095249547.png)

如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2个内存单元

如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面

![image-20220422095423867](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422095423867.png)

![image-20220422095502847](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422095502847.png)

![image-20220422095607262](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422095607262.png)

![image-20220422095845777](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422095845777.png)

页表的始址和页表长度放在进程控制块(PCB）

![image-20220422100738732](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422100738732.png)

快表：

![image-20220422103243981](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422103243981.png)

![image-20220422103655602](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422103655602.png)

![image-20220422104137934](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422104137934.png)

![image-20220422104413139](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422104413139.png)

![image-20220422104818221](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422104818221.png)



![image-20220422134512415](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422134512415.png)

**传统存储管理方式的特征、缺点**

**一次性:**作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:

①作业很大时，不能全部装入内存，导致大作业无法运行;

②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

**驻留性:**一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

![image-20220422142642793](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422142642793.png)

虚拟内存有一下三个主要特征:
**多次性:**无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
**对换性:**在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出.
**虚拟性:**从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

**虚拟内存的实现**

请求分页存储管理
请求分段存储管理
请求段页式存储管理

![image-20220422143423016](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422143423016.png)

####  17、MMU地址翻译的具体流程

MMU(Memory Management Unit)叫做内存管理单元，主要用来管理**虚拟内存与物理内存的映射**，由硬件自动完成。



####  18、缺页处理过程

![image-20220422145654751](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422145654751.png)

####  19、缺页置换算法：最久未使用算法、先进先出算法、最佳置换算法

页面置换算法：

最佳置换算法(OPT)
先进先出置换算法(FIFO)
最近最久未使用置换算法(LRU)
时钟置换算法(CLOCK)
改进型的时钟置换算法

最佳置换算法（OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

![image-20220422150227668](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422150227668.png)

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

**先进先出置换算法（FIFO）:**每次选择淘汰的页面是最早进入内存的页面实现方法:把调入内存的页面根据调入的先后顺序排成一个队列需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

**最近最久未使用置换算法（LRU，least recently used):**每次淘汰的页面是最近最久未使用的页面实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。

最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

时钟置位算法：

![image-20220422151556286](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422151556286.png)

![image-20220422153936686](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422153936686.png)

![image-20220422154008310](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422154008310.png)

![image-20220422155538370](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422155538370.png)

**抖动：**刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够)

![image-20220422155959343](C:\Users\45130\OneDrive\Work4Life\C++学习笔记\面经积累\面试必背.assets\image-20220422155959343.png)

## 网络编程

1、IO多路复用：select、poll、epoll的区别（非常重要，几乎必问，回答得越底层越好，要会使用）
 2、手撕一个最简单的server端服务器（socket、bind、listen、accept这四个API一定要非常熟练）
 3、线程池
 4、基于事件驱动的reactor模式

#####  5、边缘触发与条件触发的区别

条件触发：只要满足条件就会不断提醒你

边缘触发：每当状态变化时，触发一个事件。

"举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个read ready notfication通知应用程序可读。应用程序读了50个字节，然后重新调用api等待io事件。这时水平触发的api会因为还有50个字节可读从而立即返回用户一个read ready notfication。而边缘触发的api会因为可读这个状态没有发生变化而陷入长期等待。因此在使用边缘触发的api时，要注意每次都要读到socket返回EWOULDBLOCK为止，否则这个socket就算废了。而使水平件触发的api时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。大家常用的select就是属于水平触发这一类，长期关注socket写事件会出现CPU 100%的毛病。

#####  6、非阻塞IO与阻塞IO区别

**阻塞IO**，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。

**非阻塞IO**，指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户操作，即处于非阻塞的状态，与此同时内核会立即返回给用户一个状态值。

## 数据结构与算法

1、数组
 2、[链表]()
 3、栈
 4、队列
 5、堆
 6、[二叉树]()：二叉搜索树、平衡树、[红黑树]()
 7、B树、B+树
 8、[哈希表]()及哈希冲突
 9、[排序]()[算法]()：冒泡[排序]()、简单选择[排序]()、插入[排序]()、希尔[排序]()、归并[排序]()、堆[排序]()、快速[排序]()
 （要求能够面试时手写出堆[排序]()和快速[排序]()）
 10、二分法：[旋转数组]()找target
 11、回溯法：全排列、复原IP地址
 12、[动态规划]()（掌握基本的[动态规划]()的几个题其实就够了，如：[斐波那契数列]()、接雨水、股票的最佳买入时机）

## mySQL数据库

1、数据存储引擎：InnoDB、myISAM、Memory
 2、数据库索引类型及原理：B+树索引、[哈希表]()索引
 3、锁：悲观锁、乐观锁
 4、事务：事务的四大特性（ACID）、事务并发的三大问题、事务隔离级别及实现原理
 5、多版本并发控制实现机制（MCVV）原理