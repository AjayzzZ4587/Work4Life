# Effective C++

## 条款4：确定对象被使用前已被初始化

要么以进行直接初始化，要么用input stream进行初始化

**原则：确保每一个构造函数都将对象的每一个成员初始化**

以构造函数进行构造时，应该是属于赋值，而非初始化

在前面加一个：来进行初始化操作

规定总是在初值列中列出所有成员变量，以免还得记住哪些成员变量可以无需初值。

例如遇到const或references时，其一定需要初始化，不能被赋值

在初始化过程中，由于继承关系中有着应该的初始化进程，因此在初始化过程中，应该有着固定的成员初始化次序。

函数内的static对象称为local static对象（因为他们对函数而言是local），其他static对象称为non-local static对象。

### 避免遇到在调用前被未被初始化的情况

第一、手工初始化内置型non-member对象。
第二、使用成员初值列（member initialization lists）对付对象的所有成分
第三、在“初始化次序不确定性”加强设计

对于local static对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，local static对象才被构造出来。 

而对于non-local static对象，在main()函数开始前就已经被构造出来，并在main()函数结束后被析构。

多个编译单元内的non-local static对象经由“隐式模板具现化”形成，不但不可能决定正确的初始化次序，甚至往往不值得寻找“可决定正确次序”的特殊情况                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

条款5：了解C++默默编写并调用哪些函数

编译器可以暗中为class创建default构造函数、copy构造函数、copy assignment操作符、以及析构函数

C++不允许“让reference改指向不同对象”

所谓的引用的重新赋值，应该是:

int x,y,z;

int &x=y;

&x=z;

这种是对引用x，改变了它的指定对象，一开始是y的引用，之后，又重新说明是z的引用，这种引用的重新赋值是不允许的。

## 条款8：别让异常逃离析构函数

不要让异常函数出于处理异常的目的处理函数，而是应该在普通函数中处理这一异常，而后传出一个确认值，析构函数应该仅仅成为一个双保险中的一环。