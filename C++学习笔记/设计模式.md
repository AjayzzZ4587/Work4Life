# 设计模式

使用模式时，应该遵循**重构获得模式 Refactoring to Patterns**

### 重构关键技巧

**静态->动态**

**早绑定->晚绑定**

**继承->组会**

**静态->动态**

**紧耦合->松耦合**

## 组件协作：

### 模板分类

tips：任何一个基类，都应该写析构函数，并且写成虚析构

在稳定操作结构下，灵活应对子步骤的变化。利用虚函数，在上级类中进行稳定架构的实现，这样也是一种早绑定与晚绑定的关系

定义一个操作中的算法的骨架(稳定)，而将一些步骤**延迟**（变化）到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可**重定义(override重写)**该算法的某些特定步骤。

稳定中有变化

你不要调用我，让我来调用你

可以有实现，也可以设置成纯虚函数，一般都设定成protected方法，一般不供外界调用

### 策略模式

**动机**

假设算法将来需要变化，例如计算国际货币上的变化，如果一个新的国家加入，那么便需要加入新的算法来计算货币价值。这样会违背开闭原则。

利用多态调用，将需要改变的算法在另外的类，比如增量编译，这样就维持了开放封闭原则。不在原来代码中增加代码。

**定义一系列算法，把它们一个个封装起来，并且使它们可互相替换((变化)。该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。**

在运行时能够变化

如果有太多if else switch case的话，就应该用策略模式进行解决。这种情况是分而治之的，而不是面向对象的。有时候支持不调用的代码也是一种负担。

### 观察者模式/事件模式

C++不推荐使用多继承，只有一种情况会受到推荐，那就是当其中一个是主继承，其余的都是接口。

定义对象间的一种—对多(变化)的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

**要点总结**

使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。

目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。

观察者自己决定是否需要订阅通知，目标对象对此一无所知。

Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

实际理解就是一个需要发送通知的类，如果你将需要通知的功能都写在了类内，那么在后续设计上耦合问题就比较严重了，而从用了接口的形式，后续能在这之上设计不同的通知功能等，同时使用List等数据结构让其能够一对多的传送消息，通过遍历其中的List等，一一传递消息，进而实现自动传播的功能。观察者需要自己决定是否对这一对象进行观察。当觉得观察后会受到消息通知。

## “单一职责”模式

### 装饰模式

既有一个基类，也有一个字段Stream* stream;等运行时再装配。

在其他人的操作上再做。

**动机**

在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性;并且随着子类的增多(扩展功能的增多)，各种子类的组合(扩展功能的组合)会导致更多子类的膨胀。

**动态（组合)地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承)更为灵活（消除重复代码&减少子类个数)。**

通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差"和“多子类衍生问题”。

同时组合又同时继承

Decorator类在接口上表现为is-a Component的继承关系，即
Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。

主体操作和增加操作应该分开。

### Bridge 桥模式

**定义**

将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。



结构性的重复

又是继承转组合

在类中声明一个指针，这样就有多态性。

声明成同一个基类，在未来再对问题进行处理，这样可以将不同类写成一个，然后再靠它进行形成。

对原有类进行处理，进行拆分，有区别的部分以组合的形式引入。

基于一个原则，当同一个子类都有的情况，应该将向上提升到基类中。

又是一种运行时装配。

由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度,乃至多个纬度的变化。

> Bridge模式使用t对象间的组合关系"解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化"它们。

把各个变化维度的类，打包成一个抽象基类，然后用一个指针指向它。

## “对象创建”模式

通过“对象创建”模式绕开new，来避免对象创建(new）过程中所导致的紧耦合（依赖具体类)，从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

不应该出现细节实现，而应该是接口的形式。 

无法消灭依赖，而是将其移到别处。

### 工厂方法

定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的**实例化延迟**（目的:解耦，手段︰虚函数)到子类。



Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。

Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展(而非更改)的策略，较好地解决了这种紧耦合关系。

### 抽象工厂

**动机**

在软件系统中，经常面临着“一系列相互依赖的对象"的创建工作;同时，由于需求的变化，往往存在更多系列对象的创建工作。



将相关联的工厂凑在一起，用纯虚函数的形式。

**提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”,无需指定它们具体的类。**

### 原型模式



### 构建器

